day1

object : 사전적 정의 => 모든 물질,
= 객체    유일성, 추상데이터 타입(class)가짐, 필트(데이터 저장 slot) 가짐

Object 모델링 : 객체를 추상화 작업을 통해 프로그래밍 가능하도록 정의
추상화 : 객체의 핵심적인 것만 추출 해 내는 것
객체 지향 : 상속, 다형성, 캡슐화
메소드 호출 = 메시지 호출

힙 : 객체가 입력된 것. 비어있는공간은 가상머신이 알아서 주소 배치 해준다.
딱한번 로딩 되는공간

class area : static 이외 것들이 존재하는 것
run time에서 발생되는 에러가 처리하기 힘든 에러 잘 관리 필요합니다.


☆☆☆
JVM 실행과정 :
자바에서 프로그램을 실행한다 -> 컴파일 과정으로 생성된 Class 파일로 JVM 로딩 ->
byteCode 해석 interpret  과정으로 메모리에 리소스 할당관리
+ JVM 은 Thread Synchronization + Garbage Collection 같은 메모리 정리 작업 수행
실행될 클래스 파일을 메모리 로드 후 초기화 작업
메소드와 클래스 변수들을 해당 메모리 영역에 배치
클래스 로드 종료후 JVM이 main 메소드 찾아 지역, 객체, 참조 변수 스택 쌓음,
라인 진행 하며 작업 수행

작업 순서
(1)
- 자바소스 작성(.java 생성)-> 컴파일러가 java source를 JVM 해석가능한 java byte code변환
- 자바 컴파일러가 컴파일 하면 .class(바이트코드) 생성
- 클래스 로더로 해당 클래스 파일들을 로드
- 로딩된 바이트 코드를 해석 해 런타임 데이터 영역에 배치
+ 배번 인터프리터하여 한줄 단위 커파일 시간 소용 = JIT 컴파일 이용
++ 미이용시 바이트코드 사용시마다 인터프리터해서 실행시간 느림
(2) Class load
- JVM 내 클레스 로드 링크배치 작업,
- 동적 클래스 로드 + 클래스파일 엮어서 OS 할당받은 메모리영역(Runtime Data Area 적재)

(3) Execution Engine
- 로딩된 클래스 ByteCode 해석(interpret)
- Class Loader에 의해 JVM의 런타임 영역 배치된 바이트 코드 실행
- 메모리 적재된 클래스(byteCode) 기계어 변경후 명령어 단위 실행

(4) Garbege Collector
- 힙 메모리에 객체중 참조안된것 적재
-

static => class arae 공부할떄 딱 한번 생성, intance 아님?
- 왠만하면 사용자제 당부 드립니다. 클래스내 모두가 공유하는것


day1 추가 해야될것
=> runtime 구조, 동작 방식 정리
